<?php

namespace SaasOvation\Common\Port\Adapter\Messaging\RabbitMQ;

use Exception;
use InvalidArgumentException;
use SaasOvation\Common\Port\Adapter\Messaging\MessageException;

/**
 * I am a queue that simplifies RabbitMQ queues.
 *
 * @author Vaughn Vernon
 */
class Queue extends BrokerChannel
{
    /**
     * Answers a new instance of a Queue with the name aName. The underlying
     * queue durability, exclusivity, and deletion properties are specified by
     * explicit parameters.
     *
     * @param ConnectionSettings $aConnectionSettings the ConnectionSettings
     * @param string $aName the String name of the queue
     * @param boolean $isDurable the boolean indicating whether or not I am durable
     * @param boolean $isExclusive the boolean indicating whether or not I am exclusive
     * @param boolean $isAutoDeleted the boolean indicating whether or not I should be auto-deleted
     *
     * @return Queue
     */
    public static function instance(
        ConnectionSettings $aConnectionSettings,
        $aName,
        $isDurable = false,
        $isExclusive = false,
        $isAutoDeleted = false
    ) {
        return self::fromSettings($aConnectionSettings, $aName, $isDurable, $isExclusive, $isAutoDeleted);
    }

    /**
     * Answers a new instance of a Queue with the name aName. The underlying
     * queue is durable, is non-exclusive, and not auto-deleted.
     *
     * @param ConnectionSettings $aConnectionSettings the ConnectionSettings
     * @param string $aName the String name of the queue
     *
     * @return Queue
     */
    public static function durableInstance(ConnectionSettings $aConnectionSettings, $aName)
    {
        return self::fromSettings($aConnectionSettings, $aName, true, false, false);
    }

    /**
     * Answers a new instance of a Queue with the name aName. The underlying
     * queue is durable, exclusive, and not auto-deleted.
     *
     * @param ConnectionSettings $aConnectionSettings the ConnectionSettings
     * @param string $aName the String name of the queue
     *
     * @return Queue
     */
    public static function durableExclsuiveInstance(ConnectionSettings $aConnectionSettings, $aName)
    {
        return static::fromSettings($aConnectionSettings, $aName, true, true, false);
    }

    /**
     * Answers a new instance of a Queue that is bound to anExchange, and
     * is ready to participate as an exchange subscriber (pub/sub). The
     * connection and channel of anExchange are reused. The Queue is named
     * by aName, unless it is empty, in which case the name is generated by
     * the broker. The Queue is bound to all routing keys in aRoutingKeys,
     * or to no routing key if aRoutingKeys is empty. The Queue has the
     * qualities specified by isDurable, isExclusive, isAutoDeleted. This
     * factory is provided for ultimate flexibility in case no other
     * exchange-queue binder factories fit the needs of the client.
     *
     * @param Exchange $anExchange the Exchange to bind with the new Queue
     * @param string $aName the String name of the queue
     * @param array $aRoutingKeys the routing keys to bind the queue to
     * @param boolean $isDurable the boolean indicating whether or not I am durable
     * @param boolean $isExclusive the boolean indicating whether or not I am exclusive
     * @param boolean $isAutoDeleted the boolean indicating whether or not I should be auto-deleted
     *
     * @return Queue
     */
    public static function exchangeSubscriberInstance(
        Exchange $anExchange,
        $aName,
        array $aRoutingKeys = null,
        $isDurable = false,
        $isExclusive = true,
        $isAutoDeleted = true
    ) {
        $queue = self::fromBrokerChannel($anExchange, $aName, $isDurable, $isExclusive, $isAutoDeleted);

        try {
            if (null === $aRoutingKeys) {
                $queue->channel()->queue_bind($queue->name(), $anExchange->name(), '');
            } else {
                foreach ($aRoutingKeys as $routingKey) {
                    $queue->channel()->queue_bind($queue->name(), $anExchange->name(), $routingKey);
                }
            }
        } catch (Exception $e) {
            throw new MessageException('Failed to bind the queue and exchange.', $e);
        }

        return $queue;
    }

    /**
     * Answers a new instance of a Queue that is bound to anExchange, and
     * is ready to participate as an exchange subscriber (pub/sub). The
     * connection and channel of anExchange are reused. The Queue is
     * by aName, which must be provided and should be unique to the
     * individual subscriber. The queue is bound to all routing keys in
     * aRoutingKeys. The Queue is durable, non-exclusive, and is not
     * auto-deleted. This Queue style best works as a durable direct or
     * topic exchange subscriber.
     *
     * @param Exchange $anExchange the Exchange to bind with the new Queue
     * @param string $aName the String name of the queue, which must be unique, non-empty
     * @param array $aRoutingKeys the routing keys to bind the queue to
     *
     * @return Queue
     */
    public static function individualExchangeSubscriberInstance(Exchange $anExchange, $aName, array $aRoutingKeys = null)
    {
        if (null === $aName || empty($aName)) {
            throw new InvalidArgumentException('An individual subscriber must be named.');
        }

        $queue = self::fromBrokerChannel($anExchange, $aName, true, false, false);

        try {
            if (null === $aRoutingKeys) {
                $queue->channel()->queue_bind($queue->name(), $anExchange->name(), '');
            } else {
                foreach ($aRoutingKeys as $routingKey) {
                    $queue->channel()->queue_bind($queue->name(), $anExchange->name(), $routingKey);
                }
            }
        } catch (Exception $e) {
            throw new MessageException('Failed to bind the queue and exchange.', $e);
        }

        return $queue;
    }

    /**
     * Constructs my default state.
     *
     * @param ConnectionSettings $aConnectionSettings the ConnectionSettings
     * @param string $aName the String name of the exchange, or the empty string
     * @param boolean $isDurable the boolean indicating whether or not I am durable
     * @param boolean $isExclusive the boolean indicating whether or not I am exclusive
     * @param boolean $isAutoDeleted the boolean indicating whether or not I should be auto-deleted
     *
     * @return static
     */
    protected static function fromSettings(ConnectionSettings $aConnectionSettings, $aName, $isDurable, $isExclusive, $isAutoDeleted)
    {
        $instance = static::fromConnectionSettings($aConnectionSettings);

        $instance->setDurable($isDurable);

        try {
            $instance->channel()->queue_declare(
                $aName,
                false,
                $isDurable,
                $isExclusive,
                $isAutoDeleted
            );

            $instance->setName($aName);

        } catch (Exception $e) {
            throw new MessageException("Failed to create/open the queue.", $e);
        }
    }

    /**
     * Constructs my default state.
     *
     * @param BrokerChannel $aBrokerChannel the BrokerChannel to initialize with
     * @param string $aName the String name of the exchange, or the empty string
     * @param boolean $isDurable the boolean indicating whether or not I am durable
     * @param boolean $isExclusive the boolean indicating whether or not I am exclusive
     * @param boolean $isAutoDeleted the boolean indicating whether or not I should be auto-deleted
     *
     * @return static
     */
    protected static function fromBrokerChannel(BrokerChannel $aBrokerChannel, $aName, $isDurable, $isExclusive, $isAutoDeleted)
    {
        $instance = static::fromExistingBrokerChannel($aBrokerChannel);

        $instance->setDurable($isDurable);

        try {
            $instance->channel()->queue_declare(
                $aName,
                $isDurable,
                $isExclusive,
                $isAutoDeleted
            );

            $instance->setName($aName);

        } catch (Exception $e) {
            throw new MessageException('Failed to create/open the queue.', $e);
        }

        return $instance;
    }

    /**
     * @see com.saasovation.common.port.adapter.messaging.rabbitmq.BrokerChannel#isQueue()
     */
    protected function isQueue()
    {
        return true;
    }
}
